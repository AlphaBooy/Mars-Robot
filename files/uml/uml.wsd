This file contains the plain text to use with planUml (https://plantuml.com/fr/) to generate the uml diagram



diagram needed for all parts (we need 10 diagrams): 
- cas d'utilisation ✅
- class ✅
- séquence 
- état-transition (2) ✅(1/2)

@startuml test 
title digramme classe partie 1
class Robot {
    -config : HashMap<String, Double>
    -direction :Direction
    -laser : Laser
    -battery : Battery
    -map : Map
    -posX: int
    -posY: int
    -value : double
    -weightCarried: double
    {static} +PATH_TO_IMAGE: String
    +Robot(configPath: String)
    +Robot(map: Map, configPath: String)
    +getDirection(): Direction
    +getPosX(): int
    +getPosY(): int
    +getValue(): double
    +getLaser() : Laser
    +getBattery(): Battery
    +getWeightCarried(): double
    +{static} getConfig: HashMap<String, double>
    +rotate(direction: Direction): void
    +move(): void
    +performAction(instructions: String...): void
    +{static} getActionFromFile(path: String): String[]
    +mine(): void
    +gameover(): void
    +writeInResult(resultToWrite: String): void
    +getActionDuration(action: String)
    +{static} startGame(): void
    -{static} getCurrentRunNumber(): int
    -{static} setCurrentRunNumber(): void
}

class Material {
    -object: Object
    -cost: int
    +Material(object: Object, cost: int)
    +getDefault(): Material[]
    +getAllMaterial(path: String): ArrayList<Material>
    +isLaser(name String): boolean
    +isBattery(name: String): boolean
    +getName(): String
    +getObject(): Object
}

class Battery {
    -name: String
    -capacity: double
    -level: double
    +Battery()
    +Battery(name: String, capacity: double)
    +Battery(name String, capacity: double, level: double)
    +chargeBattery(power: double): void
    +useBattery(power: double): void
    +getImageName(): String
    -emptyBattery(): void

}
enum Direction {
    NORTH
    EAST
    SOUTH
    WEST
}

class Laser {
    -name: String
    -power: double
    +Laser()
    +Laser(name: String, power: double)
    +getPower(): double
    +loosePower(time: long, blunt: double)
}

class Map {
    -representation: char[][]
    -sizeX: int
    -sizeY: int
    -map: MapObject[][]
    +Map()
    +Map(sizeX: int, sizeY: int)
    +Map(representation: char[][])
    +generateObjects(): void
    +getRepresentation(): char[][]
    +getRepresentation(filePath: String, sizeX: int, sizeY: int): void
    +getSizeX(): int
    +getSizeY(): int
    +getObject(posX: int, posY: int): MapObject
    +setObject(posX: int, posY: int, mapObject: MapObject)
    +getBase(): MapObject
}

class MapObject {
    -posX: int
    -posY: int
    -name: String
    +mapRepresentation: char
    +MapObject(posX: int, posY: int, name: String, mapRepresentation: char)
    +MapObject(posX: int, posY: int, mapReprensation: char)
    +getName(): String
    +getName(representation: char): String
    +getPosX(): int
    +getPosY(): int
    +getAttribute(element: String): int
    +destroy(): void
    {static}+ getObject(posX: int, posY: int): MapObject
}

Robot *-- Battery
Robot *-- Laser
Robot o-- Map
Map o-- MapObject
Material <|-- Laser
Material <|-- Battery
Robot o-- Direction
@enduml

diagram cas
@startuml digramCasPart1
title Diagramme cas partie 1
:robot: as robot
rectangle Projet {
robot -(pointer une direction)
(avancer) as (avancer)
(miner) as (miner)
(avancer) .> (miner): include
robot -(avancer)
(acheter nouveaux équipement) as (acheter)
(installer nouveaux équipement) as (installer)
robot -- (acheter)
(acheter) .> (installer): include
}
@enduml

Diagram etat-transition (bouger robot)

@startuml digrammeEtatTransition_bougerRobot
title diagramme etat transition bouger robot
[*] --> bougerRobot 
state bougerRobot {
    state Avancer: after(temps déplacement)
    [*] --> Avancer
    Avancer --> miner : [position = position d'un objet]
    Avancer --> [*]
    state miner {
        [*] --> mine 
        mine : after(durreté *100 / efficacité)
        mine --> [*]
    }
    miner -> [*] : [charge robot > charge max]
    miner --> robotDetruit : [batterie <= 0]
}
@enduml

digramm sequence 

@startuml diagrammeSequencePart1
title diagramme sequence partie 1
actor Robot as Robot <<Robot>>
participant Map as Map <<Map>>
activate Robot
Robot -> Map : avancer(direction)
alt position valide
Map --> Robot : nouvelle position
Robot -> Map : objet à la position ? 

alt oui 
Map --> Robot : caractéristique de l'objet
Robot -> Map : j'ai détruit l'objet
Map -> Map : enlève l'objet de la map
else non
Map --> Robot : case vide
end
else position non disponible
Map --> Robot : en dehors de la map\nfin du jeu
destroy Robot
deactivate Robot
end
@enduml

diagram etat-transition (acheter Materiel - part1)

@startuml diagrammeEtatTransition_acheterMateriel
title diagramme etat transition acheter matériel
[*] --> AcheterMateriel
state AcheterMateriel {
    [*] --> DemandeMateriel
    state c <<choice>>
    DemandeMateriel --> c : [position robot == position base]

    c --> [*] : [non]
    c --> AcheterEquipement : [oui]

    state d <<choice>>
    AcheterEquipement --> d : [robot.value >= materiel.cost]
    d --> [*] : [non]
    d --> EquiperMateriel : [oui]
    EquiperMateriel : entry/robot.value -= materiel.cost
    EquiperMateriel : after(temps_installation)
    EquiperMateriel --> [*]

}
@enduml

diagramme cas (part2)
@startuml diagrammCasPart2
title Diagramme cas partie 2
actor :robot:
rectangle programme {
robot -- (Instruction P)
robot -- (Instruction G)
robot -- (Instruction D)
robot -- (Instruction M)
robot -- (Instruction K)
robot -- (Déplacer le robot)
robot -- (Attaquer robot à proximité)
robot -- (Soigner robot)
robot -- (Détruire mur)

"Instruction Y" as (Y)
(Déplacer le robot) ..> (Y) : include
(Attaquer robot à proximité) ..> (Y) : include
(Soigner robot) ..> (Y) : include
(Détruire mur) ..> (Y) : include

}
@enduml

diagramme etat transition partie 2 
@startuml
title diagramme etat transition instruction Y (part2)
state c <<choice>>
[*] --> c : instruction Y
c --> bougerRobot : [32 <= V <= 35]
state bougerRobot {
[*] --> Nord : [V == 33]
[*] --> Est : [V == 32]
[*] --> Ouest : [V == 34]
[*] --> Sud : [V == 35]
state d <<choice>>
Nord --> d 
Est --> d
Ouest --> d
Sud --> d 
d --> [*] : bougeRobot [pas de mur]
}
bougerRobot --> [*] : [mur dans la direction voulu]

c --> attaquerRobots : [V == 36]
state attaquerRobots {
    [*] --> energieInitiale
    energieInitiale --> energieFinale : attaque/energie --
    energieFinale  --> [*] : [energie > 0]
    energieFinale --> robotDetruit 
}
attaquerRobots --> [*]

c --> soignerRobots : [V == 37]
state soignerRobots {
    [*] --> energieRobotInitiale
    [*] --> energieBotsInitiale
    energieRobotInitiale --> energieRobotFinale : soigner/ [energie += nbBots]
    energieBotsInitiale --> energieBotsFinale : soigner/ [energie += 2]
    energieBotsFinale --> [*]
    energieRobotFinale --> [*]
}
soignerRobots --> [*]

c --> détruireMur : [V == 38]
state détruireMur {
    [*] --> energieRobotDébut
    energieRobotDébut --> energieRobotFin : détruitMur/ énergie -= nbMur
    energieRobotFin --> [*]
    energieRobotFin --> robotDétruit : [energie <: 0]
}
détruireMur --> [*]
@enduml

digramme sequence partie 2
@startuml diagramSequencePart2
title diagram sequence part2
actor robot as robot <<Robot>>
participant "Registre D" as D <<int[]>>
participant "Registre C" as C <<int[]>>
participant "Pile publique" as PP <<int[]>>
participant Map as Map <<Map>>
alt "Instruction P"
    D -> PP : donne valeur ASCII position d
    PP -> PP : empile la valeur
else "Instructin G"
    PP -> PP : dépile x
    PP->PP: x %= 2
    PP->PP : dépile y
    PP -> PP : y %= 2
    PP->PP : empile x &= y
else "Instruction D"
    D -> PP : récupère dernière valeur
    PP --> D : donne dernière valeur
    D -> D : définit D sur la \nvaleur récupérée
else "Instruction M"
    D -> PP : demande dernière valeur
    PP --> D : donne dernière valeur
    D -> D : défninit valeur à \nla position d \nà la valeur récupérée
else "Instruction K"
    C -> D : demande d
    D --> C : donne d
    C -> C : C = d
    D -> D : D = 0
else "Instruction Y"
    opt "V == 32"
        robot -> Map : mur à droite ?
        opt 
            Map --> robot : oui
            robot -> robot : reste à la même position
        else 
            Map --> robot : non
            robot -> robot : Déplace à droite
        end
    else "V == 33"
        robot -> Map : mur en haut ?
        opt 
            Map --> robot : oui
            robot -> robot : reste à la même position
        else 
            Map --> robot : non
            robot -> robot : Déplace en haut
        end
    else "V == 34"
        robot -> Map : mur à gauche ?
        
        opt 
            Map --> robot : oui
            robot -> robot : reste à la même position
        else 
            Map --> robot : non
            robot -> robot : Déplace à gauche
        end
    else "V == 35"
        robot -> Map : mur en bas ?
        opt 
            Map --> robot : oui
            robot -> robot : reste à la même position
        else 
            Map --> robot : non
            robot -> robot : Déplace à bas
        end
    else "V == 36"
        robot -> robot : Perd 1 point énergie
        opt "énergie >= 0"
            robot -> robot : Déstruction
            destroy robot
        end
    else "V == 37"
        robot -> Map : robots à côté ?
        Map --> robot : nombre robot
        robot -> robot : Gagne (nombre robot) point énergie
    else "V == 38"
        robot-> Map : nombre mur à côté ? 
        Map --> robot : nombre mur
        opt nombre mur = 0
            robot -> robot : ne fait rien
        else 
            robot -> Map : Détruit murs
            Map -> Map: enlève murs
            robot -> robot : Perd (nombre mur) point énergie
        end
        opt "énergie >= 0"
            robot -> robot : Déstruction
            destroy robot
        end 
    end
else "instruction I"
    PP -> PP : dépile x, y
    PP -> Map : demande valeur position (x, y)
    Map --> PP : donne valeur position (x, y)
    PP -> PP : empile valeur récupérée
else "Instruction inconnue"
    robot -> robot : Déstruction
    destroy robot
end 
@enduml



//TODO
diagram classe partie 2 
    A FAIRE 
